I'm planning to fill this document with explainations of nontrivial design
features found in the project. If you come across something confusing that
I haven't covered here please let me know.

------------------------------------------
Reminders about elementary Unity concepts:
------------------------------------------
Update() is called every frame and should contain visual update code and input
processing. FixedUpdate() is called every physics update and should contain
logic depending on physics. In addition to seeing these functions in
monobehaviours you will also see them World, Chunk, and Tile. Basically Update()
and FixedUpdate in GameManger call the corespodning update functions in world
which in turn calls them for chunks which in turn calls them for tiles. Player
and enemy managers have their update methods called by their monobehaviours.

------------
Conventions:
------------
When naming, "position" refers to an objects real valued position in the world
(type float). "location" refers to integer value indecies in the world and
corespond to Tiles. Each tile is one unity unit and is positioned with its
bottom left corner at it world location.

----------------
Design Patterns:
----------------
- "Two classes for one game object". Lets say we want a class to represent
something that exists in the scene like an enemy. Naturally we have a game
object with a component script with one class which inherits from MonoDevelop.
This script is neccesary to provide us with the MonoDevelop API: Update(),
OnMouseEnter() etc. . But this script does not persist through object
creation/deletion and cannot use a constructor. For this reason we use an
additional script which owns the MonoDevelop script as a property. This script
serves two purposes. First, it accepts initialization input via its constructor.
Second, it manages the instantiation and destruction of the
Prefab/MonoBehaviour. We will call the wrapper script "EnemyManager", the
MonoBahaviour script "EnemyMonoBahaviour", the prefab "EnemyPrefab", and the
GameObject doesn't matter (It's "Enemy (clone)" by default). Note that
"GameManager" is not part of this convention, think of "GameManager" as the
"Main" script and the entry point.
- "Treadmill". In order to improve performance we do not want to have the whole
world active in the hierarchy. For this reason we create objects only when the
player is "nearby" and delete them when they are "distant". We use the idea of a
"treadmill" to describe the rectangular area around the player that is active in
the hierarchy because as the player moves things will be created on one side and
deleted on the other. See the section "Chunk State" for a rational behind the
dimentions of the treadmill.
- "Pixel perfect movement". Because we want to render sprites exactly the same
as the original artwork we need the sprites to be located on the pixel grid,
instead of inbetween pixels. At the same time the objects the sprites represent
have a floating point position and we do not want to impose artificial
constraints by forcing the physics body to be located on the pixel grid as this
causes jerky, unatural movement. To solve this we use two game objects, one with
a rigid body and a collider but no sprite and one with a sprite but no rigid
body or collider. The two objects are controlled by the same monobehavior. In
conjunction with the design pattern "Two classes for one game object" this means
moving entities such as the player or the world have two scripts and to game
objects.

-------------
Chunk State: (Outdated, please wait for revision - matt 9/19)
-------------
As the player moves through the wold game objects are created and destoryed as
needed. Additionally we want enemies to spawn in chunks that are out of sight
but only those which the player approaches. For this reason we consider a chunk
to be in one of four states:
1) Live: This is a chunk that the player can see, all game objects should be
active.
2) Spawning Grounds: This is a chunk that the player cannot see where we want
to spawn enemies. Because spawning enemies requires that all game objects to be
live in order to avoid collisions we want all of the chunks contents to be 
instantiated when it enteres this state.
3) Generating/Degernerating: Because we don't want to instantiate a chunks
contents all at once but we want them to be fully instantiated when it comes
time to spawn, we require a state in which a chunk generates/degenerates over
a period of time (the time it takes a player to travers one full chunk). This
comes at the cost of having more game objects in the scene at any one time.
4) Inactive: This chunk is very far from the player and should have no game
objects and no update calls. It is still kept in memory which I might try to 
address at a later point.

Of course state 1 is the most expensive and state 4 is the least expensive and
we'd generally like states to be as low on the list as possible. Additionally
we're assuming at 1080x1920 resolution on which the player can see 60 tiles
across at any one time. For these reasons we maintain the following invarient
stated in the simplified case of one dimention:

----------------------------------------------
| -4 | -3 | -2 | -1 |  0 |  1 |  2 |  3 |  4 |
----------------------------------------------

chunks -4 onward are inactive
chunk -3 is generating/degenerating
chunk -2 is spawning grounds
chunk -1 is live
chunk 0 is live and contains the player
chunk 1 is live
chunk 2 is spawning gounds
chunk 3 is generating/degenerating
chunks 4 onward are inactive

Here is the lifecycle so to speak as the player moves from chunk -1 to 1
accross chunk 0.
The following happen in the first fixed update in which the
players position is in chunk 0.
1) Chunks 4 and -4 (namely -4) check that all of their tiles and enemies have
been destroyted.
2) Chunk 2 and -2 (namely 2) check that all of their tiles and enemies have been
created.
3) Chunks 2 and -2 (namely 2) spawn up to their maximum enemies.

The following happen while the player is in chunk 0
1) Chunks 1, 0, -1 have Update() called to update fog of war.
2) In chunks 3 and -3 every fixed update any tile/enemy less than 96f distance
from the player is created and any tile/enemy more than 96f distance is
destroyed

By the time the player reaches chunk 1, chunk 3 has had almost all its game
objects destroyed and is ready to become inactive. Chunk -2 has had its enemies 
replenished and is ready to be destroyed. Chunk 1 is out of view and is ready to
have its enemies replenihed. Chunk 2 has had its enemies replenished and is
ready to come into view. Chunk 3 has just finished being created and is ready to
have its enemies replenished. Chunk 4 will start generating.

---------------------
A note on permenence:
---------------------
I used the following guides
Original guide: https://aloiskraus.wordpress.com/2017/04/23/the-definitive-serialization-performance-guide/
.NET 4.7 update guide: https://aloiskraus.wordpress.com/2018/05/06/serialization-performance-update-with-net-4-7-2/

I first tried using BinaryFormatter serialization but it was catastrophically
slow. Then I tried protobuf-net but unity didn't recognize the nuget package
for some reason and I could not find enough information online to fix the issue.
Lastly I settled on MessagePackSharp
(https://github.com/neuecc/MessagePack-CSharp). There are four things to keep
in mind with MessagePackSharp. The first is that it is a tree type serializer as
opposed to a graph type meaning it cannot serialize cyclic references. Second is
that in order to instantiate an object while deserializing it requires a
constructor (optionally marked with [SerializationConstructor], I choose to
always mark). In most cases in this project classes contain two constructors,
the one used when intitially creating the object and the one used when
deserializing. Third it can only serialize public members. Lastly, it can't 
serialize tuples.

Also, I've made the questionable decision the persist terrain type, which James
has pointed out is uneccesary since you can just generate the terrain again.
Load time is short enough atm that I'm not going to worry about it but I'll
keep it in mind.

------------------------------------
An Explaination of World Generation:
------------------------------------
Because the world is infinite we do not generate it all at once, instead we
generate individual chunks as needed. And because the player can see chunks they
are not presetly in we make sure to initialize chunks in a radius around the
player (presently a radius of 2 or rather a 5x5 square with each chunk 32x32
tiles). This initializatin is started when the enemy first enteres a chunk or
rather on the first frame update in which the player is in a new chunk. With the
exception of rivers a chunk's terrain is generated without knowledge of
neighboring chunks. This is desireable because we can't count on a chunk's
neighbors existing when we need to initialize it (generally half of a chunks
neighbors exist when we initialize it as the player has approached continuously
from one direction, of course it isn't always the same half).

Now to address river generation imagine that a river starts in chunk A and
continues into chunk B. If chunk A is generated first then when B is initialized
it can check if there is a river in A and then continue the river into B.
Unfortunatly it can be the case that B is generated first so when it comes time
for A to generate the river either stops at the boarder to the chunk or we
trigger a "re-initializatin" of B with newfound knowledge of the river (and you
can imagine that the re-initialization may propogate to trigger chunk C to
reiniitialize if the river travels through B). But if C or even D is
re-initialized while the player is present they will witness the river spawn
which is undesireable.

So we do choose to propagate rivers into initialized chunks with the following
workaround. When the player enters chunk 0,0 from the west (from chunk -1,0) we
initialize the rivers in chunk 0,8. The rivers may propagate and reform the
terrain but only for a certain length which is dependant on the topographical
parameters. Once we do this we finalize the terrain in chunk 0,2. And per the
design pattern "Treadmill" the tiles in chunk 0,2 don't actually manifest as
game objects until the player is approximately in the middle chunk 0,1.

More explicitely, when a player enters chunk chunk 0,0 for the first time we
loop over every chunk in a 17x17 chunk radius and initialize its rivers if they
are not already initialized. This function is called "public void
InitializeRiverLocality(ChunkIndex chunkIndex)". Once that completes we loop
over every chunk in a 5x5 radius and initialize the terrain. That function is
called "public void FinalLocalityInitialization(ChunkIndex chunkIndex)".
Obviously when the player is moving in an established world the flamefront of
chunks generated is small compared to the job size when the start in a
completely new world location via spawn or teleport. But even the generation of
the flamefront is wall time expensive so we thread the job to avoid the game
pausing to generate chunks when the player moves between chunks. This means
distant chunks are being generated concurent with player movement.

Importantly we should wait for world generation jobs to finish before saving or
destroying the world.
